# -*- coding: utf-8 -*-
"""aggregated_profiles_day.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C24Jw4Q-o7LQ2cwmQ1Spu2gB96jemcH1
"""

import numpy as np
import csv
import os.path
import matplotlib.pyplot as plt
from classes.household import Household
from classes.car import Car

def aggregated_profiles_day(households,
                    meta_data_all,
                    states_all,
                    speeds_all,
                    start,
                    end,
                    no_of_ts,
                    ts_length,
                    home_charging_power,
                    work_charging_power,
                    charging_efficiency,
                    discharging_efficiency,
                    min_charge,
                    max_charge,
                    csv_weather,
                    csv_cars,
                    csv_database_electric_cars,
                    bool_winter = False,
                    bool_plot = False):
    """ create_output():
    Creates aggregated profiles
    Args:
    - *IDs:                   hh ID or list of household IDs (if multiple)
    - start:                  first timestep
    - end:                    last timestep
    - home_charging_power:    power of home charging station [kW]
    - work_charging_power:    power of work charging station [kW]
    - charging_efficiency:    efficiency of charging, default: 0.95
    - discharging_efficiency: efficiency of discharging, default: 0.95
    - min_state_of_charge:    min possible state of charge in %, default = 10%
    - max_state_of_charge:    min possible state of charge in %, default = 90%
    - path:                   path to folder for csv.-file creation
    - bool_plot:              if true: plots are created, default: False
    - bool_create_csv:        if true: csv-files are created, default: False
    """

    # create profiles for all of the following hosueholds:
    households_profiles = households    # result from rank_households
    
    # create empty array for aggregated load
    load_profile_array = []

    # create household objects
    for i in range(0, len(households)):
        ID = households_profiles[i]    # Id of current HH

        # indices of household in data set
        positions = np.where(meta_data_all[:,0] == ID)[0]

        # meta data of all household members
        meta_data = meta_data_all.astype(int)[np.where(meta_data_all[:,0] == ID)]

        # states of all household members
        for i in positions:
            states = states_all[positions, 0 : no_of_ts]

        # speeds of all household members
        for i in positions:
            speeds = speeds_all[positions, 0 : no_of_ts]
            states = states_all[positions, 0 : no_of_ts]

        # create new Household object
        household = Household(positions, 
                              meta_data, 
                              states, 
                              speeds, 
                              no_of_ts, 
                              ts_length)
        
        # create states_profiles and speed_profiles for each car in household
        states_profiles = household.generate_mobility_states_profiles(start, end)

        # swap all "0" to "8"
        states_profiles = np.where(states_profiles == 8, 8,
                              np.where(states_profiles == 1, 1, 
                                       np.where(states_profiles == 2, 2,
                                                np.where(states_profiles == 14, 14, 8))))
                              
        speeds_profiles = household.generate_mobility_speeds_profiles(start, end)

        dates = household.dates
        dates_winter = np.array([20837,20838,20839,20840,20841,20842,20843])

        temperatures = []
        # create array with all temperatures in observation period
        if (bool_winter == True):
            for i in dates_winter:
                x = np.where(csv_weather[:,0] == i)
                temperatures.append(csv_weather[x,1].astype(int)[0])
            result = np.concatenate(temperatures[0:7])
            temperature_array = result[start:end].astype(float)
        else:
            for i in dates:
                x = np.where(csv_weather[:,0] == i)
                temperatures.append(csv_weather[x,1].astype(int)[0])
            result = np.concatenate(temperatures[0:7])
            temperature_array = result[start:end].astype(float)

        # create Car objects for real dates
        for j in range(0, len(states_profiles)):
          
            # get car segment
            cars = csv_cars[np.where(csv_cars[:,0] == household.household_ID)]
            segment = cars[j : j + 1 , 174]
            if segment not in range(1, 14):  # if no segment is given, set 3
                segment = 3
            else:
                segment = segment.astype(int)

            car = Car(states_profiles[j], # only profiles for car j
                      speeds_profiles[j],  
                      temperature_array,
                      segment,
                      csv_database_electric_cars,
                      min_charge, 
                      max_charge,
                      ts_length)

            # Create profiles:
            # max_states_of_charge_profile() has to run first because of 
            # possible car segment adjustment
            max_strategy = car.max_state_of_charge_profile(start, 
                                                           end, 
                                                           home_charging_power, 
                                                           work_charging_power, 
                                                           charging_efficiency, 
                                                           discharging_efficiency)
            
            min_strategy = car.min_state_of_charge_profile(start, 
                                                           end, 
                                                           home_charging_power, 
                                                           work_charging_power, 
                                                           charging_efficiency, 
                                                           discharging_efficiency)
            
            charging_pwr_profile = car.get_charging_power(start, 
                                                          end, 
                                                          home_charging_power, 
                                                          work_charging_power)
            
            consumption_profile = car.generate_consumption_profile(start, end)

            states = car.states
            states = np.where(states == 8, 8,
                              np.where(states == 1, 1, 
                                       np.where(states == 2, 2,
                                                np.where(states == 14, 14, 0))))

            if max_strategy:     # if array not empty -> generation possible
                load_profile = max_strategy[4]
                load_profile_array.append(load_profile)

                
    agg_load = sum(load_profile_array) / 2177
    return  agg_load