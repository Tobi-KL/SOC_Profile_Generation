# -*- coding: utf-8 -*-
"""aggregated_profiles_lvp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pJz9QFG26gPOUHBVaUYnraBjups3S1Sy
"""

import numpy as np
import csv
import os.path
import matplotlib.pyplot as plt
from classes.household import Household
from classes.car import Car

def aggregated_profiles_lvp(households,
                    meta_data_all,
                    states_all,
                    speeds_all,
                    start,
                    end,
                    no_of_ts,
                    ts_length,
                    home_charging_power,
                    work_charging_power,
                    charging_efficiency,
                    discharging_efficiency,
                    min_charge,
                    max_charge,
                    csv_weather,
                    csv_cars,
                    csv_database_electric_cars,
                    bool_winter = False,
                    bool_plot = False):
    """ create_output():
    Creates aggregated profiles
    Args:
    - *IDs:                   hh ID or list of household IDs (if multiple)
    - start:                  first timestep
    - end:                    last timestep
    - home_charging_power:    power of home charging station [kW]
    - work_charging_power:    power of work charging station [kW]
    - charging_efficiency:    efficiency of charging, default: 0.95
    - discharging_efficiency: efficiency of discharging, default: 0.95
    - min_state_of_charge:    min possible state of charge in %, default = 10%
    - max_state_of_charge:    min possible state of charge in %, default = 90%
    - bool_plot:              if true: plots are created, default: False
    """

    # create profiles for all of the following hosueholds:
    households_profiles = households    # result from rank_households

    # create empty arrays for aggregated load
    load_profile_array = []
    load_profile_min_array = []
    poss_chrg_pwr_array = []

    # create household objects
    for i in range(0, len(households)):
        ID = households_profiles[i]    # Id of current HH

        # indices of household in data set
        positions = np.where(meta_data_all[:,0] == ID)[0]

        # meta data of all household members
        meta_data = meta_data_all.astype(int)[np.where(meta_data_all[:,0] == ID)]

        # states of all household members
        for i in positions:
            states = states_all[positions, 0 : no_of_ts]

        # speeds of all household members
        for i in positions:
            speeds = speeds_all[positions, 0 : no_of_ts]
            states = states_all[positions, 0 : no_of_ts]

        # create new Household object
        household = Household(positions, 
                              meta_data, 
                              states, 
                              speeds, 
                              no_of_ts, 
                              ts_length)
        
        # create states_profiles and speed_profiles for each car in household
        states_profiles = household.generate_mobility_states_profiles(start, end)

        # swap all "0" to "8"
        states_profiles = np.where(states_profiles == 8, 8,
                              np.where(states_profiles == 1, 1, 
                                       np.where(states_profiles == 2, 2,
                                                np.where(states_profiles == 14, 14, 8))))
                              
        speeds_profiles = household.generate_mobility_speeds_profiles(start, end)

        dates = household.dates
        dates_winter = np.array([20837,20838,20839,20840,20841,20842,20843])
        temperatures = []
        # create array with all temperatures in observation period
        if (bool_winter == True):
            for i in dates_qinter:
                x = np.where(csv_weather[:,0] == i)
                temperatures.append(csv_weather[x,1].astype(int)[0])
            result = np.concatenate(temperatures[0:7])
            temperature_array = result[start:end].astype(float)
        else:
            for i in dates:
                x = np.where(csv_weather[:,0] == i)
                temperatures.append(csv_weather[x,1].astype(int)[0])
            result = np.concatenate(temperatures[0:7])
            temperature_array = result[start:end].astype(float)

        # create Car objects for real dates
        for j in range(0, len(states_profiles)):
          
            # get car segment
            cars = csv_cars[np.where(csv_cars[:,0] == household.household_ID)]
            segment = cars[j : j + 1 , 174]
            if segment not in range(1, 14):  # if no segment is given, set 3
                segment = 3
            else:
                segment = segment.astype(int)

            car = Car(states_profiles[j], # only profiles for car j
                      speeds_profiles[j],  
                      temperature_array,
                      segment,
                      csv_database_electric_cars,
                      min_charge, 
                      max_charge,
                      ts_length)

            # Create profiles:
            # max_states_of_charge_profile() has to run first because of 
            # possible car segment adjustment
            max_strategy = car.max_state_of_charge_profile(start, 
                                                           end, 
                                                           home_charging_power, 
                                                           work_charging_power, 
                                                           charging_efficiency, 
                                                           discharging_efficiency)
            
            min_strategy = car.min_state_of_charge_profile(start, 
                                                           end, 
                                                           home_charging_power, 
                                                           work_charging_power, 
                                                           charging_efficiency, 
                                                           discharging_efficiency)
            
            charging_pwr_profile = car.get_charging_power(start, 
                                                          end, 
                                                          home_charging_power, 
                                                          work_charging_power)
            
            consumption_profile = car.generate_consumption_profile(start, end)

            states = car.states
            states = np.where(states == 8, 8,
                              np.where(states == 1, 1, 
                                       np.where(states == 2, 2,
                                                np.where(states == 14, 14, 0))))

            if max_strategy:     # if array not empty -> generation possible
                max_state_of_charge_profile = max_strategy[0]
                max_charge_profile = max_strategy[1]

                load_profile = max_strategy[4]
                load_profile_array.append(load_profile)

                load_profile_min = min_strategy[4]
                load_profile_min_array.append(load_profile_min)

                # possible charging power:
                poss_chrg_pwr_array.append(charging_pwr_profile)
               
    if bool_plot == True:

        fig, ax = plt.subplots(figsize=(12,6))
        figure_title = ("\nVerlauf verfügbare und geladene Energie")

        agg_load = sum(load_profile_array) / 2177      
        agg_load_min = sum(load_profile_min_array) / 2177
        poss_chrg_pwr = sum(poss_chrg_pwr_array) / 2177

        ax.plot(agg_load[144:288], color = "forestgreen", label = "Last Max Strategie")
        ax.plot(agg_load_min[144:288], color = "limegreen", label = "Last Min Strategie")
        ax.plot(poss_chrg_pwr[144:288], color = "grey", label = "verfügbar")
        ax.fill_between(range(144),poss_chrg_pwr[144:288], color="whitesmoke")

        #ax.set_xticks(np.arange(min(ax.get_xticks()),max(ax.get_xticks()),36));
        #labels = ['00:00 Uhr', '06:00 Uhr', '12:00 Uhr', '18:00 Uhr' , '00:00 Uhr']
        #ax.set_xticklabels(labels, rotation = 0)
        ax.set_xlabel("Zeit")
        ax.set_ylabel("Last, normiert [kW]")    
        plt.legend(bbox_to_anchor = (1.05, 1), loc = 'upper left')
        ax.set_title(figure_title)
        plt.tight_layout()
        plt.show()
        #plt.savefig("...", bbox_inches='tight')
        plt.close()