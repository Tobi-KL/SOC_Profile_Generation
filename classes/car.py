# -*- coding: utf-8 -*-
"""car.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UKefSH5fSHdKtfZtT3rbXcWXDkLZoZl6
"""

class Car:
    """ Class Car:
    - holds information about one car
    - calculates consumption of car & used charging stations for each timestep
    - simulates charging with 2 strategies and determines charging profiles:
      - max strategy: when possible, car is charged to max state of charge
      - min strategy: state of chrg is held as low as possible, but just enough
    - max strategy has to be run before min strategy
    """
    def __init__(self, household_ID, car_nr, min_charge, max_charge):
        """ inits Car class with:
        Args: 
          - household_ID:         ID of household to which car belongs
          - car_nr:               # of car in hh (sorted by decreasing dist.)
          - min_charge:           min state of charge allowed [in %]
          - max_charge:           max state of charge allowed
        Instance attributes:
          - segment:              segment of car 
              (can be increased, if battery cap. not enough for profile gen.)
          - capacity:             battery capacity of car [kWh](can be incr.)
          - car_charging_power:   max poss chrg power of car [kW](can be incr.)
          - min_state_of_charge:  min state of chrg allowed [kWh](can be incr.)
          - max_state_of_charge:  max state of chrg allowed [kWh](can be incr.)
          - time_z:               timestep with lowest capacity in period
        """
        self.household_ID = household_ID
        self.car_nr = car_nr
        self.min_charge = min_charge
        self.max_charge = max_charge
        self.segment = self.get_segment()
        self.capacity = csv_database_electric_cars[self.segment,3]
        self.car_charging_power = csv_database_electric_cars[self.segment,5]    
        self.min_state_of_charge = self.min_charge * self.capacity / 100
        self.max_state_of_charge = self.max_charge * self.capacity / 100
        self.time_z = 0

    def generate_consumption_profile(self, start, end):
        """ main method 1:
        returns consumption profile of car
        consumption is influenced by:
        - car segment
        - car speed
        - speed factor (depending on speed)
        - outside temperature (additional consumption due to outside temp)
        Args:
        - start: first timestep
        - end: last timestep
        """
        segment = self.get_segment()    # car segment
        weather_cons_prf = self.get_weather_consumption(start, end)
        dist_prf = self.get_distance_profile(start, end)
        base_cons = csv_database_electric_cars[segment, 4]  # base consumption
        speed_factors = self.get_speed_factors(start, end)  # speed factors
        cons_profile = np.zeros(end-start)

        # for each timestep: calculate consumption
        for i in range(len(cons_profile)):
            distance = dist_prf[i]                  
            speed_factor = speed_factors[i]
            cons_profile[i] = (speed_factor * distance * base_cons/100)

        # add weather consumption only if car is driving
        for i in range(len(cons_profile)):
            if (cons_profile[i]!=0):
                cons_profile[i] = cons_profile[i] + weather_cons_prf[i]
        return cons_profile


    def max_state_of_charge_profile(self, 
                                    start, 
                                    end, 
                                    home_chrg_pwr, 
                                    work_chrg_pwr, 
                                    eff_home, 
                                    eff_work):
        """ main method 2:
        - checks whether car can manage profile
        - generates state of charge profile for max strategy
        - max_state_of_charge_profile() has to be run before min_state_of_
              charge_profile()

        feasibility check:
        1. create state of charge profile for max strategy for current segment
        2. check, if any state_of_charge is below min_state_of_charge
        3. increase car segment to segment with higher battery capacity
        4. adjust segment, capacity, min_soc, max_soc of car object and retry
        5. if not possible with highest segment (6): don´t return profile

        Args:
        - start:          first timestep
        - last:           last timestep
        - home_chrg_pwr:  max power of charging station at home
        - work_chrg_pwr:  max power of charging station at work
        - eff_home:       efficiency of home charging station
        - eff_work:       efficiency of work charging station
        """

        # as long as there are timesteps when state_of_charge is lower than 
        # min_state_of_charge and segment can be incr. (max cap.: segment 6):
        # increase segment
        # increase cap., min_state_of_charge, max_state_of_charge accordingly
        while ((self.segment in [1,2,3,4,5]) and 
               any(x < self.min_state_of_charge for x in
                  self.max_state_of_charge_profile_wo_check(start, 
                                                            end, 
                                                            home_chrg_pwr, 
                                                            work_chrg_pwr, 
                                                            eff_home, 
                                                            eff_work)[0])):    
            self.segment = self.segment + 1
            self.capacity = csv_database_electric_cars[self.segment,3]
            self.min_state_of_charge = self.min_charge * self.capacity / 100
            self.max_state_of_charge = self.max_charge * self.capacity / 100
            print("Warning: Battery Capacity of car", self.car_nr, \
                  "not high enough. Segment is adjusted to segment:", \
                  self.segment)

        else:
            profiles = self.max_state_of_charge_profile_wo_check(start, 
                                                                 end, 
                                                                 home_chrg_pwr,
                                                                 work_chrg_pwr, 
                                                                 eff_home, 
                                                                 eff_work)
            max_state_of_charge_profile = profiles[0]
            chrg_profile = profiles[1]
            home_profile = profiles[2]
            work_profile = profiles[3]
        
        if any(x < self.min_state_of_charge 
               for x in max_state_of_charge_profile):
            print("Profile generation not possible. Capacity too low.")
        else:
            return (max_state_of_charge_profile, 
                    chrg_profile, 
                    home_profile, 
                    work_profile)
  
    def min_state_of_charge_profile(self, 
                                    start,
                                    end, 
                                    home_chrg_pwr, 
                                    work_chrg_pwr, 
                                    eff_home, 
                                    eff_work):
        """ main method 3:
        - gives state of charge profile for min strategy (w/out feas. check)
        - max_state_of_charge_profile() has to be run before 
            min_state_of_charge_profile() in order to calculate time_z
        - time_z: timestep with lowest state_of_charge for max strategy 
            -> slice here for backwards iteration
        backwards iteration: 
        1. start at time_z: set soc to min_soc
        2. iterate until timestep 0 and add/substract to soc_profile
        3. start at last timestep and iterate until time_z
        """
        consumption_profile = self.generate_consumption_profile(start, end)
        chrg_opts = self.get_charging_options(start, end)
        state_of_charge = self.min_state_of_charge      # at time_z
        state_of_charge_profile = np.zeros(end-start)
        chrg_profile = np.zeros(end-start)
        home_profile = np.zeros(end-start)    # create empty profile for home
        work_profile = np.zeros(end-start)    # create empty profile for work

        # first backwards iteration (from z-1 to first timestep)
        for i in range(self.time_z-1, -1, -1):

            # car is driving in next periode
            if (consumption_profile[i+1] != 0):
                diff = consumption_profile[i+1]  # consumption in next timestep

                # state of charge from next timestep 
                # + consumption from next timestep
                state_of_charge_profile[i] = state_of_charge + diff
                state_of_charge = state_of_charge + diff    # increase soc

            # if car at home/work in next periode
            elif ((chrg_opts[i+1] == "home") 
                    | (chrg_opts[i+1] == "work") 
                    & (state_of_charge > self.min_state_of_charge)):
                charging_location = chrg_opts[i+1]   # in next periode

                # simulate charging
                charging_results = self.min_charging(home_chrg_pwr, 
                                                     work_chrg_pwr, 
                                                     charging_location, 
                                                     state_of_charge, 
                                                     eff_home, 
                                                     eff_work, 
                                                     timestep=i)
                state_of_charge_profile[i] = charging_results[0]
                state_of_charge = charging_results[1]

                # [i+1] because of backwards iteration
                chrg_profile[i+1] = charging_results[2]

                # add consumed power to consumption profile of chrg stations
                if chrg_opts[i] == "home":
                    home_profile[i+1] = charging_results[2] * (2 - eff_home)
                elif chrg_opts[i] == "work":
                    work_profile[i+1] = charging_results[2] * (2 - eff_work)

            # car not driving and battery empty at min_state_of_charge
            else:
                state_of_charge_profile[i] = state_of_charge

        # last entry has to be min_state_of_charge
        state_of_charge_profile[end-start-1] = self.min_state_of_charge
        state_of_charge = self.min_state_of_charge

        # second backwards iteration (from last timestep to z): 
        # start with second to last
        for i in range((end-start-2), self.time_z-1, -1):
            if (i==self.time_z-1):
                state_of_charge_profile[i] = self.min_state_of_charge
                state_of_charge = self.min_state_of_charge

            # car is driving in next periode
            elif (consumption_profile[i+1] != 0):
                diff = consumption_profile[i+1] # consumption in next timestep

                # state of charge from next timestep 
                # + consumption from next timestep
                state_of_charge_profile[i] = state_of_charge + diff
                state_of_charge = state_of_charge + diff   # increase soc

              
            # if car at home/work in next periode
            elif ((chrg_opts[i+1] == "home") 
                    | (chrg_opts[i+1] == "work") 
                    & (state_of_charge > self.min_state_of_charge)):
                charging_location = chrg_opts[i+1]  #in next periode

                # simulate charging
                charging_results = self.min_charging(home_chrg_pwr, 
                                                     work_chrg_pwr, 
                                                     charging_location, 
                                                     state_of_charge, 
                                                     eff_home, 
                                                     eff_work, 
                                                     timestep=i)
                state_of_charge_profile[i] = charging_results[0]
                state_of_charge = charging_results[1]

                # [i+1] because of backwards iteration
                chrg_profile[i+1] = charging_results[2]

                # add consumed power to consumption profile of chrg stations
                if chrg_opts[i] == "home":
                    home_profile[i+1] = charging_results[2] * (2 - eff_home)
                elif chrg_opts[i] == "work":
                    work_profile[i+1] = charging_results[2] * (2 - eff_work)

             # car not driving and battery empty at min_state_of_charge
            else: 
                state_of_charge_profile[i] = state_of_charge

        return (state_of_charge_profile, 
                chrg_profile, 
                home_profile, 
                work_profile)


    def get_states(self, start, end):
        """ returns states profile for chosen car
        """
        household = Household(household_ID = self.household_ID)
        state_profile = household.generate_mobility_states_profiles(start, end)
        return state_profile [self.car_nr - 1]

    def get_speeds(self, start, end):
        """ returns speeds profile for chosen car 
        """
        household = Household(household_ID = self.household_ID)
        speed_profile = household.generate_mobility_speeds_profiles(start, end)
        return speed_profile [self.car_nr - 1]

    def get_segment(self):
        """ returns segment of car
        """
        cars = csv_cars[np.where(csv_cars[:,0] == self.household_ID)]
        segment = cars[self.car_nr - 1 : self.car_nr , 174]
        if segment not in range(1, 14):  # if no segment is given, set it to 3
            return 3
        else:
            return segment.astype(int)
    
    def get_charging_options(self, start, end):
        """ returns array with charging options ("home", "work" or "0")
        """
        states = self.get_states(start, end)
        chrg_opts = np.where((states == 8), 
                             "home", 
                             np.where((states == 1 | 2), "work", 0)) 
        return chrg_opts

    def get_charging_power(self, start, end, home_chrg_pwr, work_chrg_pwr):
        """ returns array with charing options [kW]
        home_chrg_pwr = max power possible while charging at home
        work_chrg_pwr = max power possible while charging at work
        """
        poss_chrg_pwr = np.zeros(end-start)
        chrg_opts = self.get_charging_options(start, end)
        for i in range(len(chrg_opts)):
            poss_chrg_pwr[i] = np.where(chrg_opts[i] == "home", 
                                        home_chrg_pwr, 
                                        (np.where(chrg_opts[i] == "work", 
                                                  work_chrg_pwr, 
                                                  0)))
        return poss_chrg_pwr

    def get_distance_profile(self, start, end):
        """ returns array with driven distances (in each timestep) for car
        """
        distance = np.zeros(end-start)
        for i in range(len(distance)):
            distance[i] = (ts_length / 60) * self.get_speeds(start, end)[i]
        return distance

    def get_speed_factors(self, start, end):
        """ returns factor (for multiplying consumption) for every timestep 
        depending on speed
        """
        # get speed profile and substitute entries for speed factor
        # hard coded based on assumptions
        speed_factors = self.get_speeds(start, end).copy()
        for i in range(len(speed_factors)):
            if speed_factors[i] == 0:
                speed_factors[i] = 0
            elif speed_factors[i] <= 30:
                speed_factors[i] = 1.473
            elif speed_factors[i] <= 50:
                speed_factors[i] = 1.08
            elif speed_factors[i] <= 70:
                speed_factors[i] = 0.955
            else:
                speed_factors[i] = 1.286
        return speed_factors

    def get_weather_consumption(self, start, end):
        """ returns additional consumption per timestep dep. on temperature
        - loads temperatures for dates of observation (from csv)
        - calculates heating/cooling consumption based on these assumptions:
          - heating power for 5 degrees deviation from 20°C: 0.5 [kW]
          - cooling power for 5 degrees deviation from 20°C: 0.25 [kW]
        """
        household = Household(household_ID = self.household_ID)
        dates = household.dates
        temperatures = []
        for i in dates:
            x = np.where(csv_weather[:,0]==i)
            temperatures.append(csv_weather[x,1].astype(int)[0])
            result = np.concatenate(temperatures[0:7])
            weather_consumption = result[start:end].astype(float)

        # get temperature profile and substitute entries for power consumption
        for i in range(len(weather_consumption)):
            if weather_consumption[i] <= (-20):
                weather_consumption[i] = 4 * (ts_length/60)      
            elif weather_consumption[i] <= (-15):
                weather_consumption[i] = 3.5 * (ts_length/60)
            elif weather_consumption[i] <= (-10):
                weather_consumption[i] = 3 * (ts_length/60)
            elif weather_consumption[i] <= (-5):
                weather_consumption[i] = 2.5 * (ts_length/60)
            elif weather_consumption[i] <= (0):
                weather_consumption[i] = 2 * (ts_length/60)
            elif weather_consumption[i] <= (5):
                weather_consumption[i] = 1.5 * (ts_length/60)
            elif weather_consumption[i] <= (10):
                weather_consumption[i] = 1 * (ts_length/60)
            elif weather_consumption[i] <= (15):
                weather_consumption[i] = 0.5 * (ts_length/60)
            elif weather_consumption[i] <= (20):
                weather_consumption[i] = 0 * (ts_length/60)
            elif weather_consumption[i] <= (25):
                weather_consumption[i] = 0.25 * (ts_length/60)
            elif weather_consumption[i] <= (30):
                weather_consumption[i] = 0.5 * (ts_length/60)
            elif weather_consumption[i] <= (35):
                weather_consumption[i] = 0.75 * (ts_length/60)
            elif weather_consumption[i] <= (40):
                weather_consumption[i] = 1 * (ts_length/60)
        return weather_consumption

    def max_charging(self, 
                     home_chrg_pwr, 
                     work_chrg_pwr, 
                     charging_location, 
                     state_of_charge, 
                     eff_home, 
                     eff_work, 
                     timestep):
        """ simulates charging (at home or at work) with max-strategy
        if state of charge between 80% and 100%: charging power of car reduced
        consumed energy is added to consmption profile of charging station
        how much charging is possible depends on:
          - min(charging power of charging station, charging power of car)
          - duration (timestep)
          - efficiency of charging station
        """
        car_chrg_pwr = self.car_charging_power
        if (0.8 * self.capacity < state_of_charge <= 0.85 * self.capacity):
            car_chrg_pwr = 1/2 * car_chrg_pwr
        elif (0.85 * self.capacity < state_of_charge <= 0.9 * self.capacity):
            car_chrg_pwr = 1/4 * car_chrg_pwr
        elif (0.9 * self.capacity < state_of_charge <= 0.95 * self.capacity):
            car_chrg_pwr = 1/8 * car_chrg_pwr
        elif (0.95 * self.capacity < state_of_charge <= 1.0 * self.capacity):
            car_chrg_pwr = 1/16 * car_chrg_pwr

        if (charging_location == "home"):

            # how much charging is possible? [kWh]
            possible_kwh = ((min(home_chrg_pwr, car_chrg_pwr)) 
                * (ts_length/60) * eff_home)

            # how much does car need in this timestep? [kWh]
            needed_kwh = min(possible_kwh, 
                             self.max_state_of_charge - state_of_charge)

            # consumption of charging station
            consumed_kwh = needed_kwh * (2 - eff_home)

        elif (charging_location == "work"):

            # how much charging is possible? [kWh]
            possible_kwh = ((min(work_chrg_pwr, car_chrg_pwr)) 
                * (ts_length/60) * eff_work)

            # how much does car need in this timestep? [kWh]
            needed_kwh = min(possible_kwh, 
                             self.max_state_of_charge - state_of_charge)

             # consumption of charging station
            consumed_kwh = needed_kwh * (2-eff_work)
        
        # adjust state_of_charge_profile and state_of_charge for this timestep
        # return also needed_kwh (actual used power [kWh])
        state_of_charge_profile = state_of_charge + needed_kwh
        state_of_charge = state_of_charge + needed_kwh
        
        return (state_of_charge_profile, state_of_charge, needed_kwh)

    def min_charging(self, 
                     home_chrg_pwr,
                     work_chrg_pwr,
                     charging_location,
                     state_of_charge,
                     eff_home, 
                     eff_work, 
                     timestep):
        """ simulates charging (at home or at work) with min-strategy
        if state of charge between 80% and 100%: charging power of car reduced
        consumed energy is added to consmption profile of charging station
        how much charging is possible depends on:
          - min(charging power of charging station, charging power of car)
          - duration (timestep)
          - efficiency of charging station
        """
        car_chrg_pwr = self.car_charging_power
        if (0.8 * self.capacity < state_of_charge <= 0.85 * self.capacity):
            car_chrg_pwr = 1/2 * car_chrg_pwr
        elif (0.85 * self.capacity < state_of_charge <= 0.9 * self.capacity):
            car_chrg_pwr = 1/4 * car_chrg_pwr
        elif (0.9 * self.capacity < state_of_charge <= 0.95 * self.capacity):
            car_chrg_pwr = 1/8 * car_chrg_pwr
        elif (0.95 * self.capacity < state_of_charge <= 1.0 * self.capacity):
            car_chrg_pwr = 1/16 * car_chrg_pwr

        if (charging_location == "home"):

            # how much charging is possible? [kWh]
            possible_kwh = ((min(home_chrg_pwr, car_chrg_pwr)) 
                * (ts_length/60) * eff_home)

            # how much does car need in this timestep? [kWh]
            needed_kwh = min(possible_kwh, 
                             state_of_charge - self.min_state_of_charge)

            # consumption of charging station
            consumed_kwh = needed_kwh * (2-eff_home)

        elif (charging_location == "work"):

            # how much charging is possible? [kWh]
            possible_kwh = ((min(work_chrg_pwr, car_chrg_pwr)) 
                * (ts_length/60) * eff_work)

            # how much does car need in this timestep? [kWh]
            needed_kwh = min(possible_kwh, 
                             state_of_charge - self.min_state_of_charge)

            # consumption of charging station
            consumed_kwh = needed_kwh * (2-eff_work)
          
        # adjust state_of_charge_profile and state_of_charge for this timestep 
        # negative because of backwards iteration
        # return also needed_kwh (actual used power [kWh])
        state_of_charge_profile = state_of_charge - needed_kwh
        state_of_charge = state_of_charge - needed_kwh

        return (state_of_charge_profile, state_of_charge, needed_kwh)

    def max_state_of_charge_profile_wo_check(self, 
                                             start,
                                             end, 
                                             home_chrg_pwr, 
                                             work_chrg_pwr, 
                                             eff_home, 
                                             eff_work): 
        """ this method creates max_state_of_charge_profile
        is needed for feasibility check in method max_state_of_charge_profile
        """
        state_of_charge = self.max_state_of_charge # max cap. at timestep 0
        state_of_charge_profile = np.zeros(end-start)
        consumption_profile = self.generate_consumption_profile(start, end)
        chrg_opts = self.get_charging_options(start, end)
        chrg_profile = np.zeros(end-start) # create profile for actual pwr use
        home_profile = np.zeros(end-start) # create profile for home cons.
        work_profile = np.zeros(end-start) # create profile for work cons.

        for i in range(len(state_of_charge_profile)):
            if (consumption_profile[i] != 0):           # if car is driving
                diff = consumption_profile[i]

                # subtract consumption from state_of_charge
                state_of_charge_profile[i] = state_of_charge - diff

                # adjust state_of_charge
                state_of_charge = state_of_charge - diff

            # if car at home/work and battery not full
            elif (((chrg_opts[i] == "home") 
                    | (chrg_opts[i] == "work")) 
                    & (state_of_charge < max_state_of_charge)):
                charging_location = chrg_opts[i]

                # simulate charging
                charging_results = self.max_charging(home_chrg_pwr, 
                                                     work_chrg_pwr, 
                                                     charging_location,
                                                     state_of_charge,
                                                     eff_home, 
                                                     eff_work,
                                                     timestep=i)

                # adjust state_of_charge_profile and state_of_charge
                # add concumed power to charging profile
                state_of_charge_profile[i] = charging_results[0]
                state_of_charge = charging_results[1]
                chrg_profile[i] = charging_results[2]

                # add consumed power to consumption profile of chrg stations
                if chrg_opts[i] == "home":
                    home_profile[i] = charging_results[2] * (2 - eff_home)
                elif chrg_opts[i] == "work":
                    work_profile[i] = charging_results[2] * (2 - eff_work)
            
            # car not driving, battery already full or not at charging point
            else:
                state_of_charge_profile[i] = state_of_charge

        # timestep with minimal state_of_charge
        self.time_z = np.where(
            state_of_charge_profile == state_of_charge_profile.min())[0][0]

        return (state_of_charge_profile, 
                chrg_profile, 
                home_profile, 
                work_profile)