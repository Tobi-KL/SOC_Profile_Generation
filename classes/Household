class Household:
    def __init__(self, household_ID):
        self.household_ID = household_ID
        #self.household_size = household_size
        self.position = np.where(meta_mop_filtered[:,0] == self.household_ID)[0]
        self.chosen_household = meta_mop_filtered.astype(int) [np.where(meta_mop_filtered[:,0] == self.household_ID)]

        """
        - Constructor of household object
        - householdID: ID of household (MOP-Data) -> sorted in ascending order
        - householdSize: # of occupants of household
        """
  
    def get_household(self):
      return self.chosen_household.astype(int)
    # returns chosen household (array with >= 1 entries (1 entry = 1 person, 1 year))

    def get_number_of_occupants(self):
      return self.chosen_household[0,5]
    # returns number of occupants living in chosen household
    
    def get_number_of_drivers(self):
      states = self.get_states(0,1008) # betrachte states in der ganzen Woche
      number_of_drivers = 0
      for i in range(0,len(states)):
        if ((states[i]==14).sum() > 0):
          number_of_drivers += 1
      return number_of_drivers
    # returns number of drivers (at least one state == 14) living in chosen household

    def get_drivers(self):
      states = self.get_states(0,1008) # betrachte states in der ganzen Woche
      drivers_list = []
      for i in range(0,len(states)):
          if ((states[i]==14).sum() > 0):
            drivers_list.append(self.get_data_position()[i])
      return drivers_list
    # returns list of all drivers of chosen household (nur ihre positions)
    
    def get_number_of_cars(self):
      return self.chosen_household[0,7]
    # returns number of cars of chosen household
    
    def get_data_position(self):
      position_list = []
      for i in self.position:
          position_list.append(i)
      return position_list
    # returns indeces of chosen household in data set
    
    def get_states(self, start, end):
      for i in self.position:
        return states_mop_filtered[self.position,start:end]
    # returns ALL states for timespace between start and end

    def get_adjusted_states(self, start, end):
      states = self.get_states(start,end)
      #states = np.where((states == 8) | (states == 14) | (states == 1) | (states == 2), states, 30)
      return states
    # returns adjusted states
    # 8: home; 1,2: work; 14: Car driver; 30: rest

    def get_speeds(self, start, end):
      for i in self.position:
        return speed_mop_filtered[self.position,start:end]
    # returns all speeds for timespace between start and end

    def get_persons(self, person_number):
      household_positions = self.get_data_position()
      persons = [Person (position = i, household_ID = self.household_ID) for i in household_positions]
      return persons[person_number].position
    # returns position of chosen Person-object in data set

    def get_sorted_drivers(self):
      household_drivers = self.get_drivers()
      drivers = []   
      for i in household_drivers:
        drivers.append(Person(position = i, household_ID = self.household_ID)) #erstellt für jeden driver ein Person-Object
      sorted_drivers = sorted(drivers, key=lambda x: x.total_distance, reverse=True)
      result = []
      for i in range(0,len(sorted_drivers)):
        result.append(sorted_drivers[i].position)
      return result
    # returns list with all drivers in household sorted in descending order by total distance (in whole week)
    ### testen, ob sortieren funktioniert (-> alle sind in MOP bereits absteigend sortiert!)

    def get_sorted_drivers_profiles(self, start, end):
      drivers_list = self.get_sorted_drivers()
      drivers_profiles = np.array([self.get_adjusted_states(start,end)[0]]) 
      for i in range(1, len(drivers_list)):
        drivers_profiles = np.append(drivers_profiles, [self.get_adjusted_states(start,end)[i]], axis=0) 
      return drivers_profiles
    # returns profiles of all drivers (if they don´t have to be merged)

    def get_drivers_states_profiles(self, start, end):
      if self.check_merge()==True:
        drivers_states_profiles = self.states_merge(start,end)
      else:
        drivers_states_profiles = self.get_sorted_drivers_profiles(start,end)
      return drivers_states_profiles
    # returns final states profiles for drivers  

    def check_merge(self):
      if (self.get_number_of_drivers() > self.get_number_of_cars()):
        #print("Merge necessary.")
        return True
      else:
        #print("No merge necessary.")
        return  False
    # checks whether a mobility profile merge is necessary
 
    def states_merge(self, start, end):
    # Drivers müssen bereits sortiert sein!
      x = self.get_number_of_drivers()
      while x > self.get_number_of_cars():
        drivers_positions = self.get_sorted_drivers()      #Liste aller Positionen der Drivers in data
        
        # 2. erstelle Array mit Listen aller states (für jeden driver eine Liste)
        all_states_drivers = np.array([self.get_adjusted_states(start,end)[0]]) 
        for i in range(1, len(drivers_positions)):
          all_states_drivers = np.append(all_states_drivers, [self.get_adjusted_states(start,end)[i]], axis=0)    

        # 3. betrachte ein array aus den letzten beiden Listen
        drivers_last_two = all_states_drivers[-2:]

        # 4. ziehe positions aller 14er aus der letzten Liste heraus
        list_states14_last_driver = [i for i in range(len(drivers_last_two[-1])) if drivers_last_two[-1][i] == 14]

        # 5. erzeuge eine neue Liste (vorletzte Liste komplette + 14er der letzten Liste)
        drivers_last_two_merged = all_states_drivers[-2].copy()
        for i in list_states14_last_driver:
          drivers_last_two_merged[i] = 14
        
        # 6. ersetze die letzten beiden Listen des arrays durch das neue Array
        all_states_drivers = np.delete(all_states_drivers, [-1,-2], axis=0)
        drivers_merged_profiles = np.vstack((all_states_drivers, drivers_last_two_merged))

        x -= 1
      #print("Merge completed.")
      return drivers_merged_profiles
    # returns merged states profiles

    def speed_merge(self, start, end):
    # Drivers müssen bereits sortiert sein!
      x = self.get_number_of_drivers()
      while x > self.get_number_of_cars():
        drivers_positions = self.get_sorted_drivers()      #Liste aller Positionen der Drivers in data
        
        # 2. erstelle Array mit Listen aller states (für jeden driver eine Liste) und ein Array mit Listen aller speeds
        all_states_drivers = np.array([self.get_adjusted_states(start,end)[0]])
        all_speeds_drivers = np.array([self.get_speeds(start,end)[0]]) 
        for i in range(1, len(drivers_positions)):
          all_states_drivers = np.append(all_states_drivers, [self.get_adjusted_states(start,end)[i]], axis=0)
        for i in range(1, len(drivers_positions)):
          all_speeds_drivers = np.append(all_speeds_drivers, [self.get_speeds(start,end)[i]], axis=0)
           

        # 3. betrachte ein array aus den letzten beiden Listen
        drivers_last_two_states = all_states_drivers[-2:]
        drivers_last_two_speeds = all_speeds_drivers[-2:]

        # 4. ziehe positions aller 14er aus der letzten Liste heraus
        list_states14_last_driver = [i for i in range(len(drivers_last_two_states[-1])) if drivers_last_two_states[-1][i] == 14]

        # 5. erzeuge eine neue Liste (vorletzte Liste komplette + 14er der letzten Liste)
        
        drivers_last_two_speeds_merged = all_speeds_drivers[-2].copy()
        for i in list_states14_last_driver:
          drivers_last_two_speeds_merged[i] = all_speeds_drivers[-1][i]
        
        # 6. ersetze die letzten beiden Listen des arrays durch das neue Array
        all_speeds_drivers = np.delete(all_speeds_drivers, [-1,-2], axis=0)
        drivers_merged_speed_profiles = np.vstack((all_speeds_drivers, drivers_last_two_speeds_merged))

        x -= 1
      #print("Merge completed.")
      return drivers_merged_speed_profiles
    # returns merged speed profiles

    def get_drivers_speed(self, start, end): #ohne merge (vgl. states -> umbenennen!)
      drivers_list = self.get_sorted_drivers()
      drivers_profiles = np.array([self.get_speeds(start,end)[0]])    #speeds der ersten person ##[]
      for i in range(1, len(drivers_list)):
        drivers_profiles = np.append(drivers_profiles, [self.get_speeds(start,end)[i]], axis=0) ##[]
      return drivers_profiles
    # returns array with speeds of all drivers

    def get_speeds_after_merge(self,start,end):
      if self.check_merge()==True:
        drivers_speeds_profiles = self.speed_merge(start,end)
      else:
        drivers_speeds_profiles = self.get_drivers_speed(start,end)
      return drivers_speeds_profiles

    def get_drivers_speeds_profiles(self, start, end):
      states = np.array(self.get_drivers_states_profiles(start,end))
      speeds = np.array(self.get_speeds_after_merge(start,end)) 
      mask = np.where((states==14), False, True)      #mit Hilfe der Maske werden alle Speeds, die nicht zu einem 14er state gehören, rausgefiltert
      drivers_speeds_profiles = speeds.copy()
      drivers_speeds_profiles[mask] = 0
      return drivers_speeds_profiles
    # returns final speed profiles of alle drivers (only speeds of states=14)
